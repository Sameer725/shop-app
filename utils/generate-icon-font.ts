/* eslint-disable no-console */
import fs from 'fs';

import path from 'path';
import { createSVG, createTTF } from 'svgtofont/lib/utils';
import { SvgToFontOptions } from 'svgtofont/src';
import { prettifyFileContent, toCamelCase, toScreamingSnakeCase } from './icon-font-helper-functions';

const SOURCE_DIRECTORY = path.resolve(process.cwd(), `src/assets-internal/svg-icons`);
const TARGET_DIRECTORY = path.resolve(process.cwd(), `src/assets/fonts`);
const TYPE_DIRECTORY = path.resolve(process.cwd(), `src/assets/icons`);

// Colors for console output
const enum Colors {
  RESET = '\x1b[0m',
  GREEN = '\x1b[32m',
  RED = '\x1b[31m',
  BLUE = '\x1b[34m',
}

// Comment that will be added to the auto generated files
const AUTO_GENERATED_COMMENT = `// ***************************************************** //
//                  AUTO GENERATED FILE                  //
// This file was generated by this script: yarn run icon //
//          Do not change the content manually!          //
// ***************************************************** //`;

// Map containing all available icons (duplicate icons in different styles are thus contained only once)
const iconMap = new Map<string, string>();
// Map that contains the content for the unicodeMap.json file
const unicodeMap = new Map<string, { [key: string]: string }>();

// Get all directory names in the source directory
const iconDirectories = fs
  .readdirSync(SOURCE_DIRECTORY, { withFileTypes: true })
  .filter((dirent) => dirent.isDirectory())
  .map((dirent) => dirent.name);

const NAME_PREFIX = 'kleinstarkIcon';

/**
 * Creates a ttf font containing the SVG icons from the corresponding directory
 * @param fontType Name of the font type (name of the directory, the SVG files are in)
 */
async function creatFont(fontType: string) {
  const fontName = toCamelCase(`${NAME_PREFIX}-${fontType}`);

  const options: SvgToFontOptions = {
    src: `${SOURCE_DIRECTORY}/${fontType}`,
    dist: TARGET_DIRECTORY,
    fontName,
    useNameAsUnicode: true,
    svgicons2svgfont: {
      normalize: true,
      fontHeight: 1000,
      fontName,
    },
  };

  // Creates an SVG helper file and returns a object containing the icon names
  const unicodeObject = await createSVG(options);

  // Check if there are any invalid icon names -> stop the script if so
  const invalidIcons = Object.keys(unicodeObject).filter((item) => item.match(/^\d|[^a-z\-\d]+/i));
  if (invalidIcons.length > 0) {
    console.error(
      `${Colors.RED}Error:${Colors.RESET} The following icon names are not compatible (they must not start with a number and only a-z and - are allowed). Please rename the original icon files\n`,
      invalidIcons
    );
    await deleteSvgHelperFile(options);
    process.exit(1);
  }

  // Add icons to icon map
  Object.entries(unicodeObject).forEach(([key, value]) => {
    iconMap.set(key, value);
  });

  unicodeMap.set(fontType, unicodeObject);

  await createTTF(options);

  await deleteSvgHelperFile(options);
}

/**
 * Deletes the unused SVG helper file
 * @param options SvgToFontOptions
 */
async function deleteSvgHelperFile(options: SvgToFontOptions) {
  try {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    await fs.promises.unlink(`${options.dist}/${options.fontName}.svg`);
    console.log(`${Colors.GREEN}SUCCESS${Colors.RESET} Temporary SVG file deleted`);
  } catch (e) {
    console.error('SVG helper file could not be deleted', e);
  }
}

/**
 * Creates the KsIcon.enum.ts file in the TYPE_DIRECTORY
 */
async function createEnums() {
  let fileContent: string = `${AUTO_GENERATED_COMMENT}\n\n`;

  fileContent += `export enum KS_ICON {\n`;

  const icons = Array.from(iconMap).sort(([keyA], [keyB]) => {
    const valueA = keyA.toLowerCase();
    const valueB = keyB.toLowerCase();

    if (valueA < valueB) {
      return -1;
    }
    if (valueA > valueB) {
      return 1;
    }
    return 0;
  });

  icons.forEach(([value, key]) => {
    fileContent += `  ${toScreamingSnakeCase(key)} = '${value}',\n`;
  });

  fileContent += `}\n\n`;

  fileContent += `export enum KS_ICON_STYLE {\n`;

  iconDirectories.forEach((directory) => {
    fileContent += `  ${toScreamingSnakeCase(directory)} = '${directory}',\n`;
  });

  fileContent += `}\n`;

  try {
    const filePath = `${TYPE_DIRECTORY}/KsIcon.enum.ts`;

    await fs.promises.writeFile(filePath, await prettifyFileContent(fileContent, 'typescript'));
    console.log(`${Colors.GREEN}SUCCESS${Colors.RESET} Created ${filePath}`);
  } catch (e) {
    console.error(e);
  }
}

/**
 * Creates the KsIcon.const.ts file in the TYPE_DIRECTORY
 */
async function createConstants() {
  let fileContent: string = `
    ${AUTO_GENERATED_COMMENT}

    import glyphMapJson from '../fonts/unicodeMap.json';
    import { KS_ICON, KS_ICON_STYLE } from './KsIcon.enum';

    export const KS_ICON_GLYPH_STYLE_KEYS: KS_ICON_STYLE[] = Object.keys(glyphMapJson) as KS_ICON_STYLE[];

    export const KS_ICON_GLYPH_MAP: { [key in KS_ICON_STYLE]: Partial<{ [iconKey in KS_ICON]: string }> } = glyphMapJson;

    export const KS_ICON_STYLES = {
  `;

  iconDirectories.forEach((value) => {
    const fontFamilyName = toCamelCase(`${NAME_PREFIX}-${value}`);

    fileContent += `
      ${value}: {
        fontFamily: '${fontFamilyName}',
        fontFile: '${fontFamilyName}.ttf',
        glyphMap: KS_ICON_GLYPH_MAP.${toCamelCase(value)},
      },`;
  });

  fileContent += `};`;

  try {
    const filePath = `${TYPE_DIRECTORY}/KsIcon.const.ts`;

    await fs.promises.writeFile(filePath, await prettifyFileContent(fileContent, 'typescript'));
    console.log(`${Colors.GREEN}SUCCESS${Colors.RESET} Created ${filePath}`);
  } catch (e) {
    console.error(e);
  }
}

/**
 * Creates the unicodeMap.json file in the TARGET_DIRECTORY
 */
async function createUnicodeMap() {
  const json: { [fontTypeKey: string]: { [key: string]: string } } = {};

  unicodeMap.forEach((value, key) => {
    json[key] = value;
  });

  try {
    const filePath = `${TARGET_DIRECTORY}/unicodeMap.json`;

    await fs.promises.writeFile(filePath, await prettifyFileContent(JSON.stringify(json), 'json'));
    console.log(`${Colors.GREEN}SUCCESS${Colors.RESET} Created ${filePath}`);
  } catch (e) {
    console.error(e);
  }
}

/**
 * Main function to create the icon fonts
 */
async function createIconFonts() {
  for (const fontType of iconDirectories) {
    await creatFont(fontType)
      .catch((e) => console.error(e))
      .then(() => console.log(`  âœ…  '${fontType}' done!\n`));
  }

  await createEnums();
  await createConstants();
  await createUnicodeMap();

  console.log(
    `\n\n  ${Colors.BLUE}You need to rebuild the applications after the following asset linking succeeds!${Colors.RESET}\n\n`
  );
}

// Run main function
void createIconFonts();
